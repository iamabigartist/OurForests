#include "Inlcude/VoxelStructs.compute"
#include "Inlcude/VoxelGenerationBranches.compute"
#pragma kernel GenerateTriangles

struct QuadKey
{
    int3 c_a;
    int3 c_b;

    void make(int _c_a, int _c_b)
    {
        c_a = _c_a;
        c_b = _c_b;
    }
};

//How many volumes in each dimension of the volume matrix
int3 volume_number_size;

//The volume smaller than threshold will be inside the voxel
float threshold;
StructuredBuffer<float> volume_matrix;

float grid_size;

RWStructuredBuffer<Quad> quads;

//The Pair is
//1. the index of a Quad as the key
//2. the 2 cube position c_a, c_b as the value
//The quad_dict will be covert to a dictionary by CPU,
//the value and key will be reversed.
//It aims to make CPU be able to find the quad index
//via the changed volume point and its adjacent point by querying their position
//Note that the quads array has the counter shared with the quad_dict array,
//meaning that they shared the quad index. Use the quad index to access quad in quads array.
RWStructuredBuffer<QuadKey> quad_dict;

//Debug use
RWStructuredBuffer<int> test_b;


[numthreads(1024, 1, 1)]
void GenerateTriangles(uint3 id : SV_DispatchThreadID)
{
    if (id.x == 0)
    {
        test_b[0]
        = threshold;
    }

    int3 cube_number_size = int3(
        volume_number_size.x - 1,
        volume_number_size.y - 1,
        volume_number_size.z - 1);
    int cube_number = cube_number_size.x * cube_number_size.y * cube_number_size.z;

    int i = id.x;
    if (!(i < cube_number))
        return;

    //The index position of the leftdownback corner of the cube
    int3 cube_xyz = x_xyz_index(cube_number_size, i);

    //The index positions of the 8 volume corner of the cube
    int3 index[2][2][2];

    // //The volume value
    // float v[2][2][2];


    //Whether a volume is outside the voxel
    bool outside[2][2][2];
    //Init the cube
    for (int z_axis = 0; z_axis < 2; z_axis++)
    {
        for (int y_axis = 0; y_axis < 2; y_axis++)
        {
            for (int x_axis = 0; x_axis < 2; x_axis++)
            {
                index[z_axis][y_axis][x_axis] =
                int3(
                    cube_xyz.x + x_axis,
                    cube_xyz.y + y_axis,
                    cube_xyz.z + z_axis);
                //
                // v[z_axis][y_axis][x_axis] =
                // volume_matrix[
                //     xyz_x_index(volume_number_size,
                //                 index[z_axis][y_axis][x_axis])];

                outside[z_axis][y_axis][x_axis] =
                volume_matrix[
                    xyz_x_index(volume_number_size,
                                index[z_axis][y_axis][x_axis])] < threshold;
            }
        }
    }

    for (int n = 0; n < 12; n++)
    {
        int3 c0 = quad_2_corner_in_cube[n][0];
        int3 c1 = quad_2_corner_in_cube[n][1];
        if (outside[c0.z][c0.y][c0.x] != outside[c1.z][c1.y][c1.x])
        {
            int axis_dir = quad_direction_in_cube[n];
            //0 represent the face normal dir is positive axis
            //1 represent the face normal dir is negative axis
            int reverse_dir = outside[c1.z][c1.y][c1.x] ? 0 : 1;

            //These are the offset from c1 of the 4 corner
            int3 quad_corners[4] = corner_index_offset_in_quad[axis_dir][reverse_dir];

            QuadMaker maker;
            //Apply the global index position of the 4 corner into the quad
            maker.make(
                quad_corners[0] + index[c1.z][c1.y][c1.x],
                quad_corners[1] + index[c1.z][c1.y][c1.x],
                quad_corners[2] + index[c1.z][c1.y][c1.x],
                quad_corners[3] + index[c1.z][c1.y][c1.x]);
            Quad q = maker.ToQuad();

            QuadKey key;
            key.make(
                index[c0.z][c0.y][c0.x],
                index[c1.z][c1.y][c1.x]);

            int quad_index = quads.IncrementCounter();
            quads[quad_index] = q;
            quad_dict[quad_index] = key;
        }
    }
}
