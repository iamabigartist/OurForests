---
id: 9b14lqe4s048r2dxftv8n1u
title: rendering solution
desc: ''
updated: 1646213910544
created: 1646212352378
---
## 1. 生成Mesh，然后按照常规方式来渲染

选择保留传统的结构的模型信息，然后使用常规的渲染管线来渲染，在这个过程中

1. 使用CPU 根据矩阵生成整个Mesh
2. 由于最终Mesh需要传送到GPU上，因此在CPU上修改Mesh然后再赋值没有效率，因此采用在CPU上决定好哪些Mesh中的片段需要被修改，然后将CommandBuffer传入GPU，在ComputeShader的环境下直接对于GPU中的GraphicBuffer进行数据修改，修改之后不需要再传回CPU，再传回GPU重新赋值。

## 2. 不生成Mesh，只生成旋转等面片信息，然后使用DrawInstance进行渲染

这种方式下，

1. 不需要在CPU上生成整个Mesh，可以节省大概40%的生成时间；
2. 在传入GPU渲染的时候，只需要传入per instance的信息数组即可（其他数据均可以写为静态的数组信息存储在hlsl文件中），传输数据量被压缩到很小因此生成省时间。
3. 在修改的时候不需要修改整个面片的位置信息，而是只修改面片旋转，面片对应方向，面片对应材质信息即可。在CPU上修改，在渲染的时候实时的传递这个信息数组。
4. 但是缺点在于
   1. 首先在GPU上需要更多的运算来得到实例模型，比如旋转和查找源顶点位置
   2. 其次很多图形处理，比如culling，深度检测都不能自动执行，因为是draw GPU instance，这些均需要手动来做处理脚本。
