---
id: 1myk5dmuae4j6djco5bwums
title: rendering solution
desc: ''
updated: 1646235831765
created: 1646212352378
---
## 1. 生成Mesh，然后按照常规方式来渲染

选择保留传统的结构的模型信息，然后使用常规的渲染管线来渲染，在这个过程中

1. 两种可能性
   1. 使用CPU 根据矩阵生成整个Mesh
   2. 将矩阵使用GraphicBuffer或者ComputeBuffer传入ComputeShader，然后在GPU端生成整个Mesh，将数据直接写入Mesh所在的VertexBuffer。这样的好处在于不需要从CPU传入GPU数据了，只需要GPU返回用来定位面片的反字典即可。
2. 由于最终Mesh需要传送到GPU上，因此在CPU上修改Mesh然后再赋值没有效率，因此采用在CPU上决定好哪些Mesh中的片段需要被修改，然后将CommandBuffer传入GPU，在ComputeShader的环境下直接对于GPU中的GraphicBuffer进行数据修改，修改之后不需要再传回CPU，再传回GPU重新赋值。

## 2. 不生成Mesh，只生成旋转等面片信息，然后使用DrawInstance进行渲染

这种方式下，

1. 不需要在CPU上生成整个Mesh，可以节省大概40%的生成时间；
2. 在传入GPU渲染的时候，只需要传入per instance的信息数组即可（其他数据均可以写为静态的数组信息存储在hlsl文件中），传输数据量被压缩到很小因此生成省时间。
3. 在修改的时候不需要修改整个面片的位置信息，而是只修改面片旋转，面片对应方向，面片对应材质信息即可。在CPU上修改，在渲染的时候实时的传递这个信息数组。
4. 但是缺点在于
   1. 首先在GPU上需要更多的运算来得到实例模型，比如旋转和查找源顶点位置
   2. 其次很多图形处理，比如culling，深度检测都不能自动执行，因为是draw GPU instance，这些均需要手动来做处理脚本。

## 3. 但实际上，CPU和GPU是可以合作的

1. 在CPU上检查，哪个方块的哪个面需要被渲染；然后近将这些关键信息传入GPU，包括一个面片位置V3，一个贴图索引和一个（面方向索引*6，旋转索引的压缩数据*6*6，面片中顶点的索引*4），每个顶点一份，然后通过三角形索引（非顺序索引（012230））获取一个v的信息，然后将这个索引位置转为面片中的顶点位置。
2. 有可能只传入每个quad的信息，然后通过三角形索引重复访问一个面片信息来构成两个三角形面片，但是目前无法办到的是获取每个每个顶点的独特索引，然后来获取顶点的局部坐标转换成位置。
3. 有可能在像1一样，在CPU上生成顶点的贴图索引和面索引，但是在GPU上面生成顶点的位置信息并通过i%6或者tri_i%4生成uv，在渲染的时候传入位置，贴图索引，面索引，uv渲染。
   1. 在3的基础上，可以把所有必要信息展开成单独的字段传入GPU来渲染，这样的计算消耗是最小的，但是mesh的体积是最大化的。考虑到VRAM的使用，在cache方面可能会拖慢访问速度。
   2. 在3的基础上，第二种极端是尽量压缩字段。如果动态不能添加texture，那么texture的数量也是固定的，那么甚至可以把所有信息压缩入一个i32字段中，完全不会越界（需要4971026张贴图才会越界），然后通过折叠和变平算法把一个i32变为所有的必要的索引信息。缺点就是频繁的求索引运算可能直接影响GPU渲染效率。**最终经过验证，计算解压缩索引的时间，每1000*10000 个索引需要不超过0.8 ms，非常快速。**
   3. 包括：
      1. 贴图索引
      2. 面索引
      3. 旋转索引
      4. 面片点索引
